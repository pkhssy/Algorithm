/***********************************************************
 * https://school.programmers.co.kr/learn/courses/30/lessons/60061
 *  기둥과 보를 설치하고 삭제하는 작업을 순서대로 담은 2차원 배열 build_frame이 매개변수로 주어짐
 *  n: 벽면의 크기 (5 <= n <= 100)
 *  [x, y, a, b]
 *  x, y: 기둥과 보를 설치, 삭제할 교차점의 좌표
 *  a: 0: 기둥, 1: 보
 *  b: 0: 삭제, 1: 설치
 *  모든 명령어를 수행한 후 구조물의 상태를 배열에 담아 리턴
 *  solution(5, [[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]]) => [[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]]
 *  solution(5, [[0,0,0,1],[2,0,0,1],[4,0,0,1],[0,1,1,1],[1,1,1,1],[2,1,1,1],[3,1,1,1],[2,0,0,0],[1,1,1,0],[2,2,0,1]]) => [[0,0,0],[0,1,1],[1,1,1],[2,1,1],[3,1,1],[4,0,0]]
 */

solution = (n, build_frame) => {
    const answer = [];
    const map = new Map();

    // 기둥, 보 설치 가능 여부
    const isPossible = (x, y, a) => {
        if (a === 0) { // 기둥
            // 바닥 위 || 보의 한쪽 끝 부분 위 || 다른 기둥 위 || 보의 양쪽 끝 부분 위
            if (y === 0 || map.has(`${x},${y - 1},0`) || map.has(`${x - 1},${y},1`) || map.has(`${x},${y},1`)) {
                return true;
            }
        } else { // 보
            // 한쪽 끝 부분이 기둥 위 || 양쪽 끝 부분이 다른 보와 동시에 연결 되어 있을 때 || 보의 양쪽 끝 부분이 동시에 기둥 위
            if (map.has(`${x},${y - 1},0`) || map.has(`${x + 1},${y - 1},0`) || (map.has(`${x - 1},${y},1`) && map.has(`${x + 1},${y},1`)) ) { // 보의 양쪽 끝 부분이 동시에 기둥 위
                return true;
            }
        }
        return false;
    };

    build_frame.forEach(([x, y, a, b]) => {
        const key = `${x},${y},${a}`; // 기둥, 보의 위치와 종류를 key로 사용

        if (b === 0) { // 삭제
            map.delete(key);
            // 삭제 후 다른 기둥, 보가 설치 가능한지 확인
            for (let [k, v] of map) {
                // 삭제 후 설치 불가능한 경우
                if (!isPossible(...k.split(",").map((e) => parseInt(e)))) {
                    // 삭제한 기둥, 보 다시 설치
                    map.set(key, 1);
                    break;
                }
            }
        } else { // 설치
            if (isPossible(x, y, a)) { // 설치 가능한 경우
                map.set(key, 1);
            }
        }
    });

    for (let [k, v] of map) {
        answer.push(k.split(",").map((e) => parseInt(e))); // 문자열을 숫자로 변환
    }

    return answer.sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);
};